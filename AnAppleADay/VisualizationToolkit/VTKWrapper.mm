// Copyright 2025 Lunaris Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ---------------------------------------------------------------------------
//
//  VTKWrapper.mm
//  DICOM Image Processing
//
//  Created by Giuseppe Rocco on 18/02/25.
//
//  This Objective-C++ implementation provides basic VTK functionalities, including
//  verifying that VTK is properly linked, generating simple geometrical objects, and
//  extracting surfaces from DICOM datasets via Marching Cubes. The common logic for
//  exporting vtkPolyData to an OBJ file is encapsulated in a private helper method.
//
//  DISCLAIMER: Do not edit this file unless you are fully aware of the underlying code and
//  its dependencies. Modifications may lead to unexpected behavior or break functionality.
//

#import <Foundation/Foundation.h>
#import "VTKWrapper.h"

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Weverything"

#import <vtkSmartPointer.h>
#import <vtkSphereSource.h>
#import <vtkPLYWriter.h>
#import <vtkDICOMImageReader.h>
#import <vtkMarchingCubes.h>
#import <vtkPolyData.h>

// Femur box isolation
#import <vtkBox.h>
#import <vtkExtractPolyDataGeometry.h>
#import <vtkCleanPolyData.h>
#import <vtkTransform.h>
#import <vtkTransformPolyDataFilter.h>

#pragma clang diagnostic pop

@implementation VTKWrapper

/// @brief Checks if VTK is functional by generating a small sphere and verifying
///        that it has a nonzero number of points.
/// @return YES if VTK works properly; NO otherwise.
- (BOOL)isVTKFunctional {
    
    @try {
        
        vtkSmartPointer<vtkSphereSource> sphereSource = vtkSmartPointer<vtkSphereSource>::New();
        sphereSource->SetThetaResolution(10);
        sphereSource->SetPhiResolution(10);
        sphereSource->Update();
        
        vtkSmartPointer<vtkPolyData> sphereData = sphereSource->GetOutput();
        return (sphereData->GetNumberOfPoints() > 0);
        
    } @catch (NSException *exception) { return NO; }
}

/// @brief Reads a directory of DICOM files, reconstructs a 3D surface using Marching Cubes,
/// optionally trims and translates it, and exports the resulting model.
///
/// This method uses @c vtkDICOMImageReader to load a series of DICOM slices from the specified directory.
/// It then applies a Marching Cubes filter at the provided threshold value to extract an isosurface.
/// If valid bounds are provided (i.e. both @p boxBounds and @p translationBounds are non-NULL), the
/// extracted model is trimmed to the region defined by @p boxBounds using a bounding box filter and then
/// translated so that its minimum coordinate aligns with (0,0,0) using @p translationBounds.
/// Finally, the resulting (trimmed and/or shifted) polydata is exported using a common export method.
///
/// If either @p boxBounds or @p translationBounds is NULL, the model is exported untrimmed.
///
/// @param dicomDir The filesystem path to the directory containing DICOM files.
/// @param fileName The base file name (without extension) for the output file.
/// @param threshold The isosurface threshold used by Marching Cubes (typically in Hounsfield units).
/// @param boxBounds A pointer to an array of 6 double values representing the bounding box in the form
///                  [xmin, xmax, ymin, ymax, zmin, zmax] used to trim the model. Must be non-NULL to trim.
/// @param translationBounds A pointer to an array of 3 double values representing the translation vector
///                          [tx, ty, tz] that shifts the trimmed model so its minimum is at (0,0,0).
///                          Must be non-NULL to apply translation.
///
/// @return The full filesystem path to the generated model file, or nil if an error occurs.
- (NSString *)generate3DModelFromDICOMDirectory:(NSString *)dicomDir
                                       fileName:(NSString *)fileName
                                      threshold:(double)threshold
                                      boxBounds:(const double *)boxBounds
                              translationBounds:(const double *)translationBounds {
    @try {
        // 1) Read the DICOM dataset.
        vtkSmartPointer<vtkDICOMImageReader> reader = vtkSmartPointer<vtkDICOMImageReader>::New();
        reader->SetDirectoryName([dicomDir UTF8String]);
        reader->Update();
        
        // 2) Apply Marching Cubes to extract the isosurface.
        vtkSmartPointer<vtkMarchingCubes> mc = vtkSmartPointer<vtkMarchingCubes>::New();
        mc->SetInputConnection(reader->GetOutputPort());
        mc->SetValue(0, threshold);
        mc->ComputeNormalsOn();
        mc->Update();
        
        // 3) Retrieve the resulting 3D model (polydata).
        vtkSmartPointer<vtkPolyData> polyData = mc->GetOutput();
        
        // 4) If valid bounds are provided, trim and translate the model.
        vtkSmartPointer<vtkPolyData> finalPolyData = [self trimAndTranslatePolyData:polyData
                                                                          boxBounds:boxBounds
                                                                  translationBounds:translationBounds];
        
        // 5) Export the (trimmed or untrimmed) polydata using the common export method.
        return [self exportPolyData:finalPolyData withFileName:fileName];
        
    } @catch (NSException *exception) {
        NSLog(@"❌ Error generating 3D model from DICOM: %@", exception);
        return nil;
    }
}

/// @brief Trims and translates a vtkPolyData using specified bounds.
///
/// This helper method takes an input vtkPolyData and, if valid bounds are provided,
/// trims it to include only the geometry within a bounding box defined by @p boxBounds.
/// The bounding box is specified by a 6-element array [xmin, xmax, ymin, ymax, zmin, zmax].
/// After extraction, the trimmed polydata is cleaned and then translated so that its minimum
/// coordinate aligns with (0,0,0) using the translation vector specified by the 3-element array
/// @p translationBounds ([tx, ty, tz]).
///
/// If either @p boxBounds or @p translationBounds is NULL, the original @p polyData is returned without any modification.
///
/// @param polyData The input vtkPolyData to be trimmed and translated.
/// @param boxBounds A pointer to a 6-element array of doubles defining the trim region as
///                  [xmin, xmax, ymin, ymax, zmin, zmax].
/// @param translationBounds A pointer to a 3-element array of doubles specifying the translation
///                          vector [tx, ty, tz] to apply, so that the trimmed model's minimum becomes (0,0,0).
///
/// @return A vtkSmartPointer to the resulting vtkPolyData after trimming and translation.
- (vtkSmartPointer<vtkPolyData>)trimAndTranslatePolyData:(vtkSmartPointer<vtkPolyData>)polyData
                                               boxBounds:(const double *)boxBounds
                                       translationBounds:(const double *)translationBounds {
    
    // If either bounds array is missing, do not trim or translate.
    if (boxBounds == NULL || translationBounds == NULL) {
        return polyData;
    }
    
    // Create an implicit box using the provided bounds.
    vtkSmartPointer<vtkBox> femurBox = vtkSmartPointer<vtkBox>::New();
    femurBox->SetBounds(boxBounds);
    
    // Extract the geometry within the box.
    vtkSmartPointer<vtkExtractPolyDataGeometry> extractFemur = vtkSmartPointer<vtkExtractPolyDataGeometry>::New();
    extractFemur->SetInputData(polyData);
    extractFemur->SetImplicitFunction(femurBox);
    extractFemur->Update();
    vtkSmartPointer<vtkPolyData> trimmedPolyData = extractFemur->GetOutput();
    
    // Clean the trimmed polydata.
    vtkSmartPointer<vtkCleanPolyData> cleanFemur = vtkSmartPointer<vtkCleanPolyData>::New();
    cleanFemur->SetInputData(trimmedPolyData);
    cleanFemur->Update();
    vtkSmartPointer<vtkPolyData> finalFemurPolyData = cleanFemur->GetOutput();
    
    // Translate the trimmed model so that its bounding box minimum aligns with (0,0,0).
    vtkSmartPointer<vtkTransform> transform = vtkSmartPointer<vtkTransform>::New();
    // translationBounds is expected to have three elements: [tx, ty, tz]
    transform->Translate(-translationBounds[0], -translationBounds[1], -translationBounds[2]);
    
    vtkSmartPointer<vtkTransformPolyDataFilter> transformFilter = vtkSmartPointer<vtkTransformPolyDataFilter>::New();
    transformFilter->SetInputData(finalFemurPolyData);
    transformFilter->SetTransform(transform);
    transformFilter->Update();
    vtkSmartPointer<vtkPolyData> shiftedFemurPolyData = transformFilter->GetOutput();
    
    return shiftedFemurPolyData;
}

/// @brief Helper method to export vtkPolyData as a PLY file.
/// @param polyData A pointer to the vtkPolyData to be exported.
/// @param fileName The base file name (without extension) to use for the exported file.
/// @return The full filesystem path to the generated PLY file, or nil on error.
- (NSString *)exportPolyData:(vtkPolyData *)polyData withFileName:(NSString *)fileName {
    
    @try {
        
        // Define the output file path based on the cachePath property.
        NSString *outputPath = [_cachePath stringByAppendingPathComponent:
                                [NSString stringWithFormat:@"%@.ply", fileName]];
        std::string stdFilePath = [outputPath UTF8String];
        
        // Create and configure the PLY writer.
        vtkSmartPointer<vtkPLYWriter> writer = vtkSmartPointer<vtkPLYWriter>::New();
        writer->SetFileName(stdFilePath.c_str());
        writer->SetInputData(polyData);
        writer->Write();
        
        NSLog(@"✅ Successfully exported PLY to %@", outputPath);
        return outputPath;
        
    } @catch (NSException *exception) {
        NSLog(@"❌ Error exporting vtkPolyData to PLY: %@", exception);
        return nil;
    }
}

/// @brief Initializes a new instance of VTKWrapper with a specific output directory.
/// @param directoryURL A file URL pointing to the directory where exported VTK
///        files should be saved.
/// @return An instance of VTKWrapper, or nil if initialization fails.
- (instancetype)initWithCacheDirectoryURL:(NSURL *)directoryURL {
    
    self = [super init];
    
    if (self) {
    
        // If a valid directory URL is provided, use its path;
        // otherwise, default to NSTemporaryDirectory.
        if (directoryURL) {
            _cachePath = directoryURL.path;
        }
        
        if (!_cachePath) {
            _cachePath = NSTemporaryDirectory();
        }
    }
    return self;
}

@end
