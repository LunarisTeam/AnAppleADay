// Copyright 2025 Lunaris Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ---------------------------------------------------------------------------
//
//  VisualizationToolkit.swift
//  DcmVision
//
//  Created by Giuseppe Rocco on 03/03/25.
//
//  DISCLAIMER: Do not edit this file unless you are fully aware of the underlying code and
//  its dependencies. Modifications may lead to unexpected behavior or break functionality.
//

import Foundation

import ModelIO

/// A Swift wrapper around the VTKWrapper, providing high-level 3D model generation from
/// DICOM datasets (or via simple geometric primitives) and conversion to USD format.
struct VisualizationToolkit {
    
    enum Error: Swift.Error {
        case noCacheDirectory
        case invalidFile
        case failedToGenerateModel
        case conversionToUSDFailed
        case invalidConfiguration
    }
    
    // MARK: - Properties
    
    /// The cache directory where temporary files are stored.
    private let cacheDirectory: URL
    
    /// The underlying VTKWrapper instance that provides access to VTK functionalities.
    private let vtkWrapper: VTKWrapper
    
    /// Converts any supported file format to USD.
    ///
    /// This method creates a ModelIO asset from the file located at the specified file path, then exports that
    /// asset to a new file with a "usd" extension in the same directory.
    /// If the export process fails, the method throws a DcmVisionError.conversionToUSDFailed error.
    ///
    /// - Parameter filePath: The full file system path to the file to be converted.
    /// - Throws: DcmVisionError.conversionToUSDFailed if the asset cannot be exported to USD.
    /// - Returns: The file URL of the generated USD file.
    private func convertToUSD(_ filePath: String) throws -> URL {
        
        let fileURL: URL = .init(fileURLWithPath: filePath)
        
        let mdlAsset: MDLAsset = .init(url: fileURL)
        
        let destinationURL = fileURL
            .deletingPathExtension()
            .appendingPathExtension("usd")
        
        do {
            try mdlAsset.export(to: destinationURL)
            
        } catch { throw Error.conversionToUSDFailed }
        
        return destinationURL
    }
    
    /// Retrieves a USD file from the cache and verifies its validity.
    ///
    /// This method attempts to read a USD file from the cache directory, checking whether
    /// it is a valid binary USD (`.usdc` or `.usd`) file by inspecting its header. If the file does
    /// not exist or fails validation, an error is thrown.
    ///
    /// - Parameter fileName: The name of the USD file to retrieve.
    /// - Throws:
    ///   - `DcmVisionError.invalidFile` if the file exists but is not a valid binary USD file.
    ///   - Any errors encountered while accessing the file system (e.g., file not found).
    /// - Returns: A `URL` pointing to the validated USD file within the cache directory.
    private func getNamedUSDFromCache(_ fileName: String) throws -> URL {
                
        let fileHandle = try FileHandle(
            forReadingFrom: cacheDirectory.appendingPathComponent(fileName, conformingTo: .usd)
        )
        
        let headerData = fileHandle.readData(ofLength: "PXR-USDC".count)
        fileHandle.closeFile()
        
        guard let headerString = String(data: headerData, encoding: .utf8),
              headerString.contains("PXR-USDC") else {
            throw Error.invalidFile
        }
        
        return cacheDirectory.appendingPathComponent(fileName, conformingTo: .usd)
    }
    
    // MARK: - Public Methods
    
    /// Generates a 3D model from a DICOM dataset and converts it to a USD file.
    ///
    /// This function first checks whether a USD version of the requested model is already cached by calling
    /// `getNamedUSDFromCache(_:)`. If a cached model is found, its URL is returned immediately.
    ///
    /// If no cached model exists, the function proceeds to use the VTKWrapper to:
    ///
    /// 1. Read the DICOM files from the provided directory.
    /// 2. Apply a Marching Cubes isosurface extraction at the specified threshold (in Hounsfield units).
    /// 3. Optionally trim the resulting 3D model to a region of interest using the provided bounds:
    ///    - `boxBounds`: A 6-element array ([xmin, xmax, ymin, ymax, zmin, zmax]) defining the bounding box.
    ///    - `translationBounds`: A 3-element array ([tx, ty, tz]) used to translate the trimmed model so that
    ///      its minimum coordinates align with (0,0,0).
    ///
    /// If either `boxBounds` or `translationBounds` is provided, they must have 6 and 3 elements respectively;
    /// otherwise, an `Error.invalidConfiguration` is thrown and no trimming is performed.
    /// The (optionally trimmed) model is exported as a PLY file, which is then loaded into a ModelIO asset and
    /// converted to a USD file.
    ///
    /// - Parameters:
    ///   - dataSet: The data structure containing information about the dicom dataSet
    ///   - threshold: The isosurface threshold (typically in Hounsfield units for CT data) used in the Marching Cubes algorithm.
    ///   - boxBounds: An optional array of 6 doubles ([xmin, xmax, ymin, ymax, zmin, zmax]) that defines the region to trim the model.
    ///   Pass nil to skip  trimming but be aware that translationBounds needs to be nil in this case
    ///   - translationBounds: An optional array of 3 doubles ([tx, ty, tz]) that defines the translation vector
    ///   to apply to the trimmed model so its  minimum aligns with (0,0,0). Must be provided if boxBounds is non-nil.
    ///
    /// - Returns: The file URL of the generated USD model.
    ///
    /// - Throws:
    ///   - `DcmVisionError.failedToGenerateModel` if the VTKWrapper fails to generate the PLY file.
    ///   - `DcmVisionError.conversionToUSDFailed` if the conversion to USD fails.
    ///   - `Error.invalidConfiguration` if the provided bounds arrays do not contain the expected number of elements.
    func generateDICOM(
        dataSet: DicomDataSet,
        threshold: Double,
        boxBounds: [Double]? = nil,
        translationBounds: [Double]? = nil
    ) throws -> URL {
                    
        if let boxBounds, boxBounds.count != 6 {
            throw Error.invalidConfiguration
        }
        
        if let translationBounds, translationBounds.count != 3 {
            throw Error.invalidConfiguration
        }
        
        let tokens: [String] = [
            dataSet.name,
            threshold.description,
            boxBounds?.map { $0.description }.joined(separator: "_") ?? "default",
            translationBounds?.map { $0.description }.joined(separator: "_") ?? "default"
        ]
        
        if let cachedURL = try? getNamedUSDFromCache(tokens.joined(separator: "-")) {
            return cachedURL
        }
        
        guard let vtkOutput = vtkWrapper.generate3DModel(
            fromDICOMDirectory: dataSet.url.path(percentEncoded: false),
            fileName: tokens.joined(separator: "-"),
            threshold: threshold,
            boxBounds: boxBounds,
            translationBounds: translationBounds
        ) else {
            throw Error.failedToGenerateModel
        }
            
        return try convertToUSD(vtkOutput)
    }

    
    // MARK: - Initialization
    
    /// Initializes a new instance of VisualizationToolkit.
    ///
    /// This initializer retrieves a cache directory from the user's caches folder and
    /// instantiates the VTKWrapper with that directory.
    ///
    /// - Throws: `DcmVisionError.noCacheDirectory` if no cache directory can be found.
    init() throws {
        
        // Retrieve the system cache directory
        guard let cacheDirectory = FileManager.default.urls(
            for: .cachesDirectory,
            in: .userDomainMask
        ).first else {
            throw Error.noCacheDirectory
        }
        
        self.cacheDirectory = cacheDirectory
        
        // Initialize the VTKWrapper with the cache directory.
        self.vtkWrapper = VTKWrapper(cacheDirectoryURL: cacheDirectory)
    }
}
